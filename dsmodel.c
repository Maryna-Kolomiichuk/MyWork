#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model MyWork.Tutorial3.Tests.MachineTest
 Dymola Version 2020 (64-bit), 2019-04-10 translated this at Thu Sep 12 14:37:23 2024

   */

#include <matrixop.h>
#if defined(DynSimStruct) || defined(BUILDFMU)
static double DymArrays0[3]={0.0, 0.0, 0.0};
#endif
/* Declaration of C-structs */
/* Prototypes for functions used in model */
/* Codes used in model */
/* DSblock C-code: */

#define NX_    3
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    20
#define NP_    9
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ 1062587126
#define NHash2_ -1592355235
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  0
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    46
#define SizePre_ 0
#define SizeEq_ 2
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 0
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="MyWork.Tutorial3.Tests.MachineTest";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/olego/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[8]={2 , 2 , 1 , 2 , 1 , 3 , 0 , 0};
DYMOLA_STATIC int QJacobianGC_[7]={
1 , 0 , 1 , 3 , 3 , 0 , 0};
DYMOLA_STATIC double QJacobianCD_[4]={0  , 44 , 55 , 60};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1) = 3;
DYNX(W_,4) = false;
DYNX(W_,10) = false;
DYNX(W_,19) = 3;
memcpy(&DYNX(W_,14), &DymArrays0, sizeof(double)*3);
DYNX(W_,18) = 0.0;
DYNX(W_,12) = 0.0;
DYNX(W_,17) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
DYNX(W_,5) = DYNX(DP_,2);
AssertModelica(1+DYNX(DP_,3)*(DYNX(W_,5)-DYNX(DP_,2)) >= 1E-15,"1+machine.resistor.alpha*(machine.resistor.T-machine.resistor.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
BoundParameterConstantSection
DYNX(W_,7) = DYNX(DP_,1)*(1+DYNX(DP_,3)*(DYNX(W_,5)-DYNX(DP_,2)));
BoundParameterSection
InitialSection
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(W_,17) = 0.0;
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(W_,0) = DYNX(DP_,5)*DYNX(X_,0);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[1] */
DYNX(F_,2) = RememberSimple_(DYNX(F_,2), 0);
SolveScalarLinearParametric(DYNX(DP_,8)+DYNX(DP_,0),"inertia.J+machine.inertia.J",
   DYNX(W_,0),"machine.inertia.flange_a.tau", DYNX(F_,2),"der(inertia.w)");
DYNX(W_,13) = DYNX(DP_,0)*DYNX(F_,2)-DYNX(W_,0);
 /* End of Equation Block */ 

DYNX(F_,1) = DYNX(X_,2);
DYNX(W_,2) = DYNX(W_,7)*DYNX(X_,0);
DYNX(W_,3) = DYNX(DP_,7)-DYNX(W_,2);
DYNX(W_,9) = DYNX(DP_,5)*DYNX(X_,2);
DYNX(W_,8) = DYNX(W_,3)-DYNX(W_,9);
 /* Linear system of equations to solve. */
DYNX(F_,0) = RememberSimple_(DYNX(F_,0), 1);
SolveScalarLinearParametric(DYNX(DP_,4),"machine.inductor.L", DYNX(W_,8),
  "machine.inductor.v", DYNX(F_,0),"der(machine.inductor.i)");
 /* End of Equation Block */ 


AcceptedSection1

AcceptedSection2
DYNX(W_,11) = DYNX(X_,1)-DYNX(DP_,6);
DYNX(W_,6) = DYNX(W_,2)*DYNX(X_,0);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareAlias2("machine.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 1, 4)
DeclareVariable("machine.inertia.flange_a.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("machine.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 1, 4)
DeclareAlias2("machine.inertia.flange_b.tau", "Cut torque in the flange [N.m]", \
"machine.flange_b.tau", 1, 5, 13, 132)
DeclareParameter("machine.inertia.J", "Moment of inertia [kg.m2]", 0, 0.001, 0.0,\
1E+100,0.0,0,560)
DeclareVariable("machine.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("machine.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 "inertia.phi", 1, 1, 1, 0)
DeclareAlias2("machine.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "inertia.w", 1, 1, 2, 0)
DeclareAlias2("machine.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 "inertia.w", 1, 1, 2, 0)
DeclareAlias2("machine.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 "inertia.der(w)", 1, 6, 2, 0)
DeclareAlias2("machine.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "inertia.der(w)", 1, 6, 2, 0)
DeclareParameter("machine.resistor.R", "Resistance at temperature T_ref [Ohm]", 1,\
 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("machine.resistor.T_ref", "Reference temperature [K|degC]", 2, \
300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("machine.resistor.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 3, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("machine.resistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.resistor.p.v", "Potential at the pin [V]", \
"constantVoltage.V", 1, 7, 7, 4)
DeclareAlias2("machine.resistor.p.i", "Current flowing into the pin [A]", \
"machine.inductor.i", 1, 1, 0, 132)
DeclareVariable("machine.resistor.n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("machine.resistor.n.i", "Current flowing into the pin [A]", \
"machine.inductor.i", -1, 1, 0, 132)
DeclareAlias2("machine.resistor.i", "Current flowing from pin p to pin n [A]", \
"machine.inductor.i", 1, 1, 0, 0)
DeclareVariable("machine.resistor.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("machine.resistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("machine.resistor.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.resistor.T_heatPort", "Temperature of heatPort [K|degC]",\
 "machine.resistor.T", 1, 5, 5, 0)
DeclareVariable("machine.resistor.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("machine.inductor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.inductor.p.v", "Potential at the pin [V]", \
"machine.resistor.n.v", 1, 5, 3, 4)
DeclareAlias2("machine.inductor.p.i", "Current flowing into the pin [A]", \
"machine.inductor.i", 1, 1, 0, 132)
DeclareVariable("machine.inductor.n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("machine.inductor.n.i", "Current flowing into the pin [A]", \
"machine.inductor.i", -1, 1, 0, 132)
DeclareState("machine.inductor.i", "Current flowing from pin p to pin n [A]", 0,\
 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("machine.inductor.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("machine.inductor.L", "Inductance [H]", 4, 0.05, 0.0,0.0,0.0,0,560)
DeclareVariable("machine.emf.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("machine.emf.k", "Transformation coefficient [N.m/A]", 5, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("machine.emf.v", "Voltage drop between the two pins [V]", \
"machine.inductor.n.v", 1, 5, 9, 0)
DeclareAlias2("machine.emf.i", "Current flowing from positive to negative pin [A]",\
 "machine.inductor.i", 1, 1, 0, 0)
DeclareVariable("machine.emf.phi", "Angle of shaft flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("machine.emf.der(phi)", "der(Angle of shaft flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 "inertia.w", 1, 1, 2, 0)
DeclareAlias2("machine.emf.w", "Angular velocity of flange relative to support [rad/s]",\
 "inertia.w", 1, 1, 2, 0)
DeclareAlias2("machine.emf.tau", "Torque of flange [N.m]", "machine.inertia.flange_a.tau", -1,\
 5, 0, 0)
DeclareAlias2("machine.emf.tauElectrical", "Electrical torque [N.m]", \
"machine.inertia.flange_a.tau", 1, 5, 0, 0)
DeclareAlias2("machine.emf.p.v", "Potential at the pin [V]", "machine.inductor.n.v", 1,\
 5, 9, 4)
DeclareAlias2("machine.emf.p.i", "Current flowing into the pin [A]", \
"machine.inductor.i", 1, 1, 0, 132)
DeclareVariable("machine.emf.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,521)
DeclareAlias2("machine.emf.n.i", "Current flowing into the pin [A]", \
"machine.inductor.i", -1, 1, 0, 132)
DeclareAlias2("machine.emf.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 1, 4)
DeclareAlias2("machine.emf.flange.tau", "Cut torque in the flange [N.m]", \
"machine.inertia.flange_a.tau", -1, 5, 0, 132)
DeclareParameter("machine.emf.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 6, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("machine.emf.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "machine.emf.fixed.phi0", 1, 7, 6, 1028)
DeclareAlias2("machine.emf.fixed.flange.tau", "Cut torque in the flange [N.m]", \
"machine.inertia.flange_a.tau", -1, 5, 0, 1156)
DeclareAlias2("machine.emf.internalSupport.tau", "External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau) [N.m]",\
 "machine.inertia.flange_a.tau", 1, 5, 0, 1024)
DeclareAlias2("machine.emf.internalSupport.phi", "External support angle (= flange.phi) [rad|deg]",\
 "machine.emf.fixed.phi0", 1, 7, 6, 1024)
DeclareAlias2("machine.emf.internalSupport.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "machine.emf.fixed.phi0", 1, 7, 6, 1028)
DeclareAlias2("machine.emf.internalSupport.flange.tau", "Cut torque in the flange [N.m]",\
 "machine.inertia.flange_a.tau", 1, 5, 0, 1156)
DeclareAlias2("machine.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 1, 4)
DeclareVariable("machine.flange_b.tau", "Cut torque in the flange [N.m]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareAlias2("machine.p.v", "Potential at the pin [V]", "constantVoltage.V", 1,\
 7, 7, 4)
DeclareAlias2("machine.p.i", "Current flowing into the pin [A]", \
"machine.inductor.i", 1, 1, 0, 132)
DeclareVariable("machine.n.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("machine.n.i", "Current flowing into the pin [A]", \
"machine.inductor.i", -1, 1, 0, 132)
DeclareParameter("constantVoltage.V", "Value of constant voltage [V]", 7, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("constantVoltage.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "constantVoltage.V", 1, 7, 7, 0)
DeclareAlias2("constantVoltage.p.v", "Potential at the pin [V]", \
"constantVoltage.V", 1, 7, 7, 4)
DeclareAlias2("constantVoltage.p.i", "Current flowing into the pin [A]", \
"machine.inductor.i", -1, 1, 0, 132)
DeclareVariable("constantVoltage.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,\
0.0,0,521)
DeclareAlias2("constantVoltage.n.i", "Current flowing into the pin [A]", \
"machine.inductor.i", 1, 1, 0, 132)
DeclareAlias2("constantVoltage.i", "Current flowing from pin p to pin n [A]", \
"machine.inductor.i", -1, 1, 0, 0)
DeclareVariable("ground.p.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("ground.p.i", "Current flowing into the pin [A]", 0.0, 0.0,0.0,\
0.0,0,777)
DeclareAlias2("inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 1, 4)
DeclareAlias2("inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
"machine.flange_b.tau", -1, 5, 13, 132)
DeclareAlias2("inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 1, 4)
DeclareVariable("inertia.flange_b.tau", "Cut torque in the flange [N.m]", 0.0, \
0.0,0.0,0.0,0,777)
DeclareParameter("inertia.J", "Moment of inertia [kg.m2]", 8, 1, 0.0,1E+100,0.0,\
0,560)
DeclareVariable("inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareState("inertia.phi", "Absolute rotation angle of component [rad|deg]", 1,\
 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 2, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "inertia.der(w)", 1, 6, 2, 0)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartEqBlock
DoRemember_(DYNX(F_,2), 0.0, 0);
DoRemember_(DYNX(F_,0), 0.0, 1);
EndEqBlock
EndDataBlock
